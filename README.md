# Курс объектно-ориентированного программирования на МКН СПбГУ
## Занятие 1: объявление классов и их компонентов

На этом занятии мы реализуем класс для представления несократимых (приведённых) дробей и воспользуемся им для решения
двух различных задач. Работа будет разделена на несколько этапов. Результаты каждого этапа следует отправлять на GitHub
сразу после его выполнения с целью обсуждения во время занятия различных возможных подходов к реализации.

### План занятия
1. Создание индивидуального репозитория для занятия на GitHub и его импорт в локальный проект в VS\Rider
2. Локальная работа с проектом: редактирование, запуск программ и запуск тестов, отправка решений на сервер в конце каждого этапа
3. Создание пулл-реквеста (на ветку `task`) по готовности решения.
   
### Этап 1: свойства и первичный конструктор

Реализуйте класс `Rational` для представления несократимых (приведённых) дробей значениями числителя (numerator, целое число)
и знаменателя (denominator, положительное целое число). Переданные при создании экземпляра класса значения числителя 
и знаменателя могут быть сократимыми, а также могут иметь произвольные знаки, поэтому перед инициализацией соответствующих 
свойств класса необходимо выполнить предобработку.

Для выполнения задания определите два неизменяемых (`readonly`) целочисленных свойства и инициализируйте их в конструкторе. 
    Необходимые вспомогательные функции рекомендуется объявлять вне класса. Реализуйте также используемый в тестах
    метод `ToString`, который должен выводить числитель и знаменатель через знак дроби `/` либо как целое число, 
    если знаменатель равен единице:

```c#
public override string ToString()
{
    return ???;
}
```

Убедитесь, что тест `Phase1Test` выполняется без ошибок.

Добавьте вычисляемые логические свойства `IsWhole`, `IsZero`, целочисленное свойство `WholePart` для целой части 
дроби и свойство `ProperPart` типа `Rational` для дробной части дроби в виде положительной правильной дроби.
При определении последнего свойства вы можете столкнуться с проблемами, которые можно решить несколькими способами
Про свойства можно почитать [здесь](https://learn.microsoft.com/ru-ru/dotnet/csharp/programming-guide/classes-and-structs/using-properties).

**Вопросы для обсуждения**:
* почему в этой задаче не годится `record class`?
* как создать экземпляр класса?
* что такое первичный конструктор класса?
* почему здесь требуется инициализирующий блок?
* в чём разница между параметрами первичного конструктора (список в скобках после имени класса) и свойствами экземпляра класса?
* в чём смысл проблем с определением свойства `properPart` и как их лучше решать?

### Этап 2: вторичные конструкторы

Создавать экземпляры объекта класса дроби только из числителя и знаменателя не всегда удобно. В частности, иногда 
удобнее воспользоваться смешанной дробью (целая часть, числитель дробной части, знаменатель дробной части), иногда
хочется создать дробь со значением, совпадающим с заданной дробью. Наконец, может быть удобно указать строковое 
представление (числитель и знаменатель через дробь). Для всех этих целей можно использовать перегруженные конструкторы.

Определите в классе `Rational` три указанных конструктора. 
Затем раскомментируйте тест в файле `Phase2Test.cs`, воспользуйтесь автоматической генерацией
метода Equals в классе `Rational` (он пригодится для тестирования): `Code/Override methods` в главном меню Rider, 
и убедитесь, что ваши конструкторы работают.

**Вопросы для обсуждения**:
* зачем нужно более одного конструктора? 
* можно ли обойтись только одним конструктором, ограничившись внешней функцией, возвращающей экземпляр класса?
* как контролировать корректность параметров конструктора?

### Этап 3: операторные функции

Самое приятное в собственном классе дроби — это его использование в инфиксных выражениях. Для этого нам 
понадобятся возможность [перегрузки операторов](https://learn.microsoft.com/ru-ru/dotnet/csharp/language-reference/operators/operator-overloading).
Определите операции сложения, вычитания, умножения и деления дробей. Не забудьте и об унарных плюсе и минусе.

Также нам обычно хочется сравнивать дроби операциями `<`, `>`, `<=` и `>=`. Для этого можно отнаследовать класс `Rational` от интерфейса `IComparable<Rational>`, определить
функцию `СompareTo`, которая принимает на вход дробь (правый аргумент операции) и возвращает отрицательное, 
нулевое или положительное значения в зависимости от того, является ли дробь в экземпляре класса (левый аргумент операции)
меньше, равной или больше заданной в параметрах, и вызывать её в реализации перегружаемых операторов.

Для проверки собственной реализации раскомментируйте тесты в файле `Phase3Test.cs`.

Чтобы работали выражения вида `целое + дробь`, нужно также реализовать [неявное преобразование типа](https://learn.microsoft.com/ru-ru/dotnet/csharp/language-reference/operators/user-defined-conversion-operators):
```c#
public static implicit operator Rational(int i) => new (i, 1);
```

Реализуйте такие функции и допишите для них тесты.

**Вопросы для обсуждения**:
* что такое синтаксический сахар?
* почему иногда не стоит переопределять операции для собственных классов?

### Этап 4: таблица умножения

Пусть дано некоторое `n`. Напечатайте таблицу умножения для всех дробей со знаменателем `n`
и числителями от 1 до `n-1` (до приведения к несократимой дроби). Например, для заданного числа 6 таблица
умножения должна получиться примерно такой (обратите внимание на выравнивание столбцов):
```
       1/6     1/3     1/2     2/3    5/6
-------------------------------------------
1/6    1/36    1/18    1/12    1/9    5/36 
1/3    1/18    1/9     1/6     2/9    5/18 
1/2    1/12    1/6     1/4     1/3    5/12 
2/3    1/9     2/9     1/3     4/9    5/9  
5/6    5/36    5/18    5/12    5/9    25/36
```

На этом этапе менять и добавлять что-то в класс `Rational` не следует.  
Результаты этого этапа не проверяются тестами, поэтому проверяйте их самостоятельно.

### Этап 5: смешанные дроби и символы Unicode для печати дробей

Unicode содержит для некоторых дробей специальные символы, например: ¼ или ⅜. Такие символы называются [*vulgar fractions*
(обыкновенные дроби)](https://en.wikipedia.org/wiki/Number_Forms). Для дробей, символы для которых Unicode не предусматривает,
можно использовать верхние и нижние индексы, например: ¹³/₄₂. Такая нотация позволяет красиво печатать смешанные дроби,
то есть дроби с целой частью и дробной частью в виде положительной правильной дроби, например:  -1¹/₂ (для дроби -3/2). 

Реализуйте функцию `ToMixedVulgarFraction` в файле `VulgarFractions.cs`, которая возвращает
строковое представление заданной дроби в виде смешанной дроби со специальными символами Юникода в дробной части.

Для проверки этой функции реализуйте маленький генератор заданий для младшеклассников на сложение дробей.
Программа должна печатать выражения вида `дробь + дробь = дробь`, где одна из дробей заменена на знак вопроса. 
Учитель может взять вывод такой программы и выдать в качестве задания школьникам. Для его удобства можно также
предусмотреть режим, в котором рядом с заданиями печатаются ответы на них.

**Вопросы для обсуждения (или самостоятельного обдумывания, если занятие уже закончилось)**:
* почему не стоит заменять реализацию `ToString` в классе `Rational` на `ToMixedVulgarFraction`?
* нормально ли писать обычные функции, если мы вроде как пишем программу с классами и изучаем объектно-ориентированное программирование?
* сработал ли у вас доступ к мапе `VulgarFractions` или пришлось что-то допиливать в классе `Rational`?

Вернитесь к этому заданию ближе к концу курса и перепроектируйте результаты четвёртого и пятого
этапов так, чтобы можно было бы легко менять формат таблицы и выводимых в ней дробей. Помимо исходного формата
и дробей со спецсимволами Юникода можно также предусмотреть генерацию таблицы в HTML и LaTeX.

### Начисление баллов за занятие

* По одному сырому баллу за тесты по этапам 1–3.
